In .bashrc, .bash_profile, .zshrc
export PATH=${PATH}:/usr/local/mysql/bin

$>mysql start
Run instatnce of mysql DMS.

mysql$>exit; quit; \q; ctrl c;
Quits from mysql command line interface.

$>mysql stop
Stops Mysql server.

To go in 
$>mysql -u root -p
To set user
mysql$>ALTER USER 'root'@'localhost' IDENTIFIED BY 'your_pasword'

CREATE DATABASE your_name_db;
DROP DATABASE your_name_db;
USE your_name_db - tell that we want to talk with some space on server.
SELECT database(); - see what db we are using right now.

TABLES
Relational database - is just a bunch of tables.
Tables hold the data. A collection of related data held in a struvctured format within a database.

Collums (headers)
        /       \
+------------+------------+
| host       | memory     | 
+------------+------------+
| localhost1 |  1.85      | <- row
+------------+------------+
| localhost2 |  2.50      | <- row
+------------+------------+

DATA TYPES
Mixed types of data in collumn is not allowed in sql. Simply, memory column shouldn't have "1.85" and "two fifty"
in rows, because if we want to fire some mathematical operation with these data, we'll fail on "two fifty".
When you creating table - you set data type for each column.

Numeric types:
INT (common), SMALLINT, TINYINT, MEDIUMINT, BIGINT, DECIMAL, NUMERIC, FLOAT, DOUBLE, BIT.
String types:
CHAR, VARCHAR (common), BINARY, VARBINARY, BLOB, TEXT, ENUM, SET. 
Date types:
DATE, DATETIME, TIMESTAMP, TIME, YEAR

INT - whole number, form -4294967295 to 4294967295
VARCHAR - 'variation characters' length. from 1 to 255 characters.

Each variable (int, or varchar) - still has set length. So that's why we need to check sometimes does the field
contain 100 chars, and doesn't contain 101.

Table
CREATE TABLE table_name (column_name1 data_type, column_name2 data_type);
mysql$>create table users(name varchar(15), age int);

SHOW COLUMNS FROM table_name; ( in this context simular to describe command - DESC table_name;)

DROP TABLE table_name;

INSERT DATA
insert into table_name(column_name1, column_name2) values(value_for_column1, value_for_2);
insert into table_name(column_name1, column_name2)
 values(value1_for_column1, value1_for_2)
        ,(value2_for_column1, value2_for_2); - we can set a few rows at once.

If you typed a insert into a(c1, c2) values(1) - even if c2 column has default value - you'll get an error.

strings inserted only inquotes ""|''. column names order matters.

Example of mysql$>DESC tweets;
+------------+--------------+------+-----+---------+-------+
| Field      | Type         | Null | Key | Default | Extra |
+------------+--------------+------+-----+---------+-------+
| author     | varchar(15)  | YES  |     | NULL    |       |
| tweet_text | varchar(140) | YES  |     | NULL    |       |
| likes      | int(11)      | YES  |     | NULL    |       |
+------------+--------------+------+-----+---------+-------+

SQL WARNINNGS
In previous versions of mysql if data is too long for example - it will be truncated - that's warning.
But as I see now, in 8th version - that's an error.
You can see SHOW ERRORS, or SHOW WARNING, to see the last messages (works not so properly)
If there were two simular warnings in row - it won't show it. I dunno why.

NULL value
NULL in sql means - "Value is unknown" - doesn't mean zero!
in desc table there is NULL column - if there is YES, then value or row can be NULL, means you can leave this 
row value unset - with NULL. You can even "insert into table_name() values()" - and it will set NULL from values
in whole row.
To specify that value cannot be null - we can set NOT NULL into column data type when we crating table.
mysql$>create table users(name varchar(15) not null, age int not null);
And in NULL column you'll see NO value.
If we try to leave some value unset in this table - we'll get warning and we'll have 0 as a default value in table
for examlpe. OR if we try to set NULL manualy - we'll get error.
Same thing with string, - default for it is empty string, not null.

DEFAUL VALUE
There is Default column in desc table, so if value is unset - default value comes into play.
We can manage it when creating table.
mysql$>create table cats(name varchar(15) default 'unnamed', age int default 1, lives int default 9)

KEY
          cats
+---------+------+-------+
| name    | age  | lives |
+---------+------+-------+
| Blue    |    5 |     9 |
| Blue    |    5 |     9 |
+---------+------+-------+

In this case we have two different cats but with same data. And we have no ability to unify them.
Query will return first cat and htat's all.
So to solve this we need to add some ID to cats.
And there is a term for this - Primary key. This is unic identifier for row of data.

create table unic_cats(cat_id int not null, name varchar(15) not null default 'unnamed',
 age int not null default 0, primary key(cat_id));

will create table with unic identifier;

desc unic_cats;
+--------+-------------+------+-----+---------+----------------+
| Field  | Type        | Null | Key | Default | Extra          |
+--------+-------------+------+-----+---------+----------------+
| cat_id | int(11)     | NO   | PRI | NULL    | auto_increment |
| name   | varchar(15) | NO   |     | unnamed |                |
| age    | int(11)     | NO   |     | 0       |                |
+--------+-------------+------+-----+---------+----------------+

After that we cannot add "insert into unic_cats(name, age, cat_id) values('Blue', 5, 1);" twice.
We will be forced to set unic identifier to cat_it.
We can also set name, or age a primary key, to make it unic. 

To not set cat_id each time manualy, we cat set AUTO_INCREMENT to it.
create table unic_cats(cat_id int not null auto_increment primary key, name varchar(15) not null default 'unnamed',
 age int not null default 0);
sic! primary key - not in the end like primary key(cat_id), but after cat_id in columns section of the query.

CRUD
create (create table table_name(), insert into table_name() values(), ()),
read (desc, show, select),
update (),
delete (drop)

DELETE
drop table table_name;


SELECT
* - means give me all the collumns from table.

Select expression - more complex query.
mysql$>select column_name1, column_name2 from table_name; - return only queried columns. Order of column is matter.

where
More specific selection. can be used with update, and delete.
mysql$>select column_name1, column_name2 from table_name where column_name1 condition1 and condition2;

mysql$>select age, name from unic_cats where age=4 and name = 'Egg'; (or 'egg/EGG') -> by default case not matter
mysql$>select age, name from unic_cats where age=cat_id; (sql got that I want from unic_cats)

alias
Selecting data and renaming column names to their to be more readable to you.
mysql$>SELECT age AS years, name as 'cat name' FROM unic_cats; (to use space in column name - use quotes '')
+-------+----------+
| years | cat name |
+-------+----------+
|     5 | Ringo    |
|     4 | Jackson  |
+-------+----------+
And you'll get 'years' and 'cat name' istead of age and name in column names.

UPDATE